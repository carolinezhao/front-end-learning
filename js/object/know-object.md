书的第二部分

# 第3章 对象

## 3.1 语法

## 3.2 类型

内置对象：对象子类型

String, Number, Boolean, Object, Function, Array, Date, RegExp, Error

* strin, number, boolean 对应的构造形式；
* null 和 undefined 没有构造形式；
* Date 只有构造形式；
* Object, Function, Array, RegExp -- 都是对象；
* Error 很少显式创建。

## 3.3 内容

对象的内容是由一些存储在特定命名位置的任意类型的值组成的，称之为**属性**。
“内容”其实只是表现形式。在引擎内部，值的存储方式是多种多样的，**一般并不会存在对象容器内部**。
存储在对象容器内部的是这些属性的名称，它们就像**指针** (从技术角度来说就是引用) 一样，指向这些值真正的存储位置。

object.a 属性访问；
object["a"] 键访问。

在对象中，属性名永远都是字符串。如果使用 string 以外的其他值作为属性名，它首先会被转换为一个字符串。数字也不例外。

### 3.3.1 可计算属性名
--> _01-es6-literalnotation.js_

### 3.3.2 属性与方法

如果访问的对象属性是一个函数，通常会叫做“方法”进行区分。但函数永远不会“属于”一个对象，所以这种称呼有些不妥。

有些函数具有 this 引用，有时这些 this 确实会指向调用位置的对象引用。但是这种用法本质上并没有把一个函数变成一个“方法”，因为 **this 是在运行时根据调用位置动态绑定的**，所以函数和对象的关系最多也只能说是间接关系。

如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别 (除了可能发生的隐式绑定 this，as just said)。最保险的说法是，js 中“函数”和“方法”可以互换。

--> _know-object-property.js_

### 3.3.3 数组

### 3.3.4 复制对象

### 3.3.5 属性描述符

### 3.3.6 不变性

### 3.3.7 [[Get]]

### 3.3.8 [[Put]]

### 3.3.9 Getter 和 Setter

### 3.3.10 存在性