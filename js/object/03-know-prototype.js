// 滥用：模仿“类”。利用了函数的一种特殊性：
// 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象：
// function Foo() {}
// Foo.prototype; // { }

// 这个对象被称为 Foo 的“原型”，因为可以通过名为 Foo.prototype 的属性引用来访问它。
function Foo() {}

var a = new Foo();

console.log(Object.getPrototypeOf(a) === Foo.prototype); // true

/* this-8 中讲过
使用 new 来调用函数，或者说发生构造函数调用时，会自动执行以下操作：
1.创建 (或构造) 一个全新的对象；
2.这个新对象会被执行[[Prototype]]连接；
3.这个新对象会绑定到函数调用的 this；
4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
*/

// 在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。

// 但是在 js 中，并没有类似的复制机制。
// 不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。
// 但是在默认情况下不会进行复制？？，因此这些对象之间并不会完全失去联系，它们是互相关联的。

// new Foo() 会生成一个新对象，这个新对象的内部链接[[Prototype]]关联的是 Foo.prototype 对象。
// 最后得到的是两个对象，它们之间互相关联。(并没有初始化一个类，复制到一个对象中)

// new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。
// 更直接的方法是 Object.create()，后面介绍。

// “原型继承”不能很好地反映对象之间的关联机制，作者使用“委托”。