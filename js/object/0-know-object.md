书的第二部分

# 第3章 对象

- [第3章 对象](#3)
    - [3.1 语法](#31)
    - [3.2 类型](#32)
    - [3.3 内容](#33)
        - [3.3.1 可计算属性名](#331)
        - [3.3.2 属性与方法](#332)
        - [3.3.3 数组](#333)
        - [3.3.4 复制对象](#334)
        - [3.3.5 属性描述符](#335)
        - [3.3.6 不变性](#336)
        - [3.3.7 [[Get]]](#337-get)
        - [3.3.8 [[Put]]](#338-put)
        - [3.3.9 Getter 和 Setter](#339-getter--setter)
        - [3.3.10 存在性](#3310)
    - [3.4 遍历](#34)

## 3.1 语法

## 3.2 类型

内置对象：对象子类型

String, Number, Boolean, Object, Function, Array, Date, RegExp, Error

* string, number, boolean 对应的构造形式；
* null 和 undefined 没有构造形式；
* Date 只有构造形式；
* Object, Function, Array, RegExp -- 都是对象；
* Error 很少显式创建。

## 3.3 内容

对象的内容是由一些存储在特定命名位置的任意类型的值组成的，称之为**属性**。
“内容”其实只是表现形式。在引擎内部，值的存储方式是多种多样的，**一般并不会存在对象容器内部**。
存储在对象容器内部的是这些属性的名称，它们就像**指针** (从技术角度来说就是引用) 一样，指向这些值真正的存储位置。

object.a 属性访问；
object["a"] 键访问。

在对象中，属性名永远都是字符串。如果使用 string 以外的其他值作为属性名，它首先会被转换为一个字符串。数字也不例外。

### 3.3.1 可计算属性名
--> _01-es6-literalnotation.js_

### 3.3.2 属性与方法

如果访问的对象属性是一个函数，通常会叫做“方法”进行区分。但函数永远不会“属于”一个对象，所以这种称呼有些不妥。

有些函数具有 this 引用，有时这些 this 确实会指向调用位置的对象引用。但是这种用法本质上并没有把一个函数变成一个“方法”，因为 **this 是在运行时根据调用位置动态绑定的**，所以函数和对象的关系最多也只能说是间接关系。

如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别 (除了可能发生的隐式绑定 this，as just said)。最保险的说法是，js 中“函数”和“方法”可以互换。

--> _02-know-object-property.js_

### 3.3.3 数组

内容很少，更多见 中卷

### 3.3.4 复制对象

--> _02-know-object-copy.js_

### 3.3.5 属性描述符

参考 0-prof-object.md 中的 6.1.1

书中详细讲了各描述符，不常用，略。

### 3.3.6 不变性

暂时用不上，略。

### 3.3.7 [[Get]]

属性访问，比如 `myObejct.a` 在 myObject 上实现了 [[Get]] 操作 (有点像函数调用)。

对象默认的内置 [[Get]] 操作：
- 首先在对象中查找是否有名称相同的属性，如果找到了就返回属性值。
- 如果没找到，则查找 [[Prototype]] 链 (见 第5章)。
- 如果无论如何都没有找到，则返回 undefined。

这和访问变量时的情况不同。如果引用了当前词法作用域中不存在的变量，会报错 ReferenceError。

```js
var myObejct = {
    a: undefined
}
myObject.a; // undefined
myObject.b; // undefined
```
虽然这两个引用都返回了 undefined，但实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理。

根据返回值无法判断变量的值为 undefined 还是变量不存在。(见 3.3.10)

### 3.3.8 [[Put]]

[[Put]] 被触发时，实际行为取决于许多因素。

- 对象中是否已经存在这个属性？
    - 如果已经存在 ---
        - 属性是否是访问描述符？如果是并且存在 setter 就调用 setter。
        - 属性的数据描述符中 writable 是否为 false？
        - 如果以上都不是，则将该值设置为属性的值。
    - 如果不存在这个属性 --- 操作更加复杂。见 第5章。

### 3.3.9 Getter 和 Setter

对象默认的 [[Put]] 和 [[Get]] 操作分别控制属性值的设置和获取。

ES5 中使用 getter 和 setter 部分改写默认操作，但是只能用在单个属性上，无法应用在整个对象上。两者都是隐藏函数，分别在获取和设置属性值时调用。

当给一个属性定义 getter 和 setter 时，这个属性会被定义为“访问描述符”。 --> 相关特性见 0-prof-object.md 中的 6.1.1

--> _02-know-object-getter.js_

### 3.3.10 存在性

## 3.4 遍历

结合 es6/iterator