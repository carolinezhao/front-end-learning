## 第1章 作用域是什么

comment

1.1 和 1.2 是特色，有助于理解函数执行的原理，高程里没有讲过。

---

### 1.1 编译原理

JS 是编译语言。但不同于其他语言，JS 的编译过程不是发生在构建之前，而是在代码执行前的瞬间。

传统编译语言的编译步骤如下，JS 引擎要复杂得多。

1. 分词/词法分析 Tokenizing/Lexing

    字符串分解成词法单元 token<br>
    var a = 2; --> var, a, =, 2, ;

2. 解析/语法分析 Parsing

    词法单元流（数组）转换成 “抽象语法树 AST”

3. 代码生成

    AST 转换成可执行代码。

### 1.2 理解作用域

Roles

* 引擎 Engine
* 编译器 Compiler
* 作用域 Scope：是一套规则，用于确定在何处以及如何查找变量（标识符）。

Steps

    var a = 2;
    
声明被分解为两个独立步骤：一个由编译器在编译时处理；一个由引擎在运行时处理。

step1 代码执行前进行

    var a

编译器询问作用域：

    if (已经有该名称的变量) {
        编译器忽略该声明，继续编译
    } else {
        要求作用域声明一个新变量，命名为 a
    }

step2

    a = 2

编译器为引擎生成运行时所需的代码，用于处理赋值操作。

引擎询问作用域：

    if (查找存在叫做 a 的变量) {
        引擎使用这个变量
    } else {
        引擎继续查找该变量 【1.3内容】
        if (找到) {
            将 2 赋值给 a
        } else {
            抛出一个异常 【1.4内容】
        }
    }

引擎的查询方式（根据目的，选择查询）：

* LHS 赋值操作的目标是谁 --> 找到变量的容器本身，对变量赋值 --> 如 `a = 2 或 调用函数时传参`
* RHS 谁是赋值操作的源头 --> 获取变量的值 --> 如 `console.log(a)`

辨析 LHS 和 RHS：

    function foo(a) {
        console.log(a)
    }
    foo(2)

**引擎告诉作用域要使用哪种引用 --> 作用域回答 --> 引擎实施操作**

RHS --> 编译器声明了这个函数 --> 调用 foo(...)<br>
LHS --> 编译器把 a 声明为 foo 的一个形式参数 --> 2 作为参数传递给 foo(...)，相当于 a = 2 隐式地分配值<br>
RHS --> console 是个内置对象 --> 检查是否有叫做 log 的方法，是个函数<br>
RHS --> a 没变过 --> 把 a 的值传给 console.log(...)<br>
**(下面不太懂)**<br>
在概念上可以理解为：在 LHS 和 RHS 之间通过对值 2 进行交互来将其传递进 log(...) (通过变量 a 的 RHS 查询)<br>
假设在 log(...) 函数的原生实现中它可以接受参数，在将 2 赋值给 arg1 参数之前，这个参数需要进行 LHS 引用查询。

【以上过程参考 1.2.4 引擎和作用域的对话】

练习

    function foo(a) {
        var b = a
        return a + b
    }
    var c = foo(2)

LHS 为 c 赋值<br>
RHS foo() 调用<br>
LHS a = 2<br>
LHS 为 b 赋值<br>
RHS 查找 a 的值（赋值时）<br>
RHS 查找 a 的值（return 时）<br>
RHS 查找 b 的值（return 时）<br>

---

### 1.3 作用域嵌套

与高程讲的类似，唯一区别是引入了 RHS 和 LHS。比如查找某个变量的值时，RHS 若无法在函数作用域内完成，则在上级作用域查找。抵达最外层（全局作用域）时，无论是否找到，查找都停止。

---

### 1.4 异常

变量没有声明的情况下，LHS 和 RHS 的行为不一样。

找不到变量时：

* RHS：引擎抛出 ReferenceError
* LHS：全局作用域中创建一个具有该名称的变量，并将其返还给引擎。<br> ES5 严格模式下，禁止自动创建全局变量，引擎也抛出 ReferenceError

查询到变量，但想进行不合理操作时（如对非函数类型值进行调用；引用 null 或 undefined 的属性）：

* RHS：引擎抛出 TypeError

**总结两种异常出现的情景**

* ReferenceError 与作用域判别失败相关。
* TypeError 作用域判别成功了，但是对结果的操作是非法或不合理的。