# function

## 文件对应内容

### prof-function

* 高程 3.7 函数
* 高程 5.5 Function 类型

### es6-arrow-function

* 深入理解ES6 第3章 函数 - 箭头函数

### prof-scope

* 高程 4.2 执行环境及作用域

### prof-function-expressions

* 高程 4.3 垃圾收集

### prof-garbage-collection

* 高程 第7章 函数表达式

### know-1-scope

* 你不知道的JS 第1章 作用域是什么

### know-2-scope

* 你不知道的JS 第2章 词法作用域

### know-3-scope

* 你不知道的JS 第3章 函数作用域和块作用域

### es6-block-scope

* 深入理解ES6 第1章 块级作用域绑定

### know-closure

* 你不知道的JS 第5章 作用域闭包

### closure-1/-2

* Node.js开发指南 附录A

---
---

## 知识点整合

### keywords: 执行环境，作用域链，闭包

reference

《JavaScript 高级程序设计》

* 4.2 执行环境与作用域链
* 7.2 闭包
* 5.5.3 作为值的函数（闭包中涉及）

《你不知道的 JavaScript》(上卷) 

* 第3章 函数作用域和块作用域 (未整合到以下内容)
* 第5章 作用域闭包 (未整合到以下内容)

<br>
Q: 什么是执行环境、变量对象、作用域链？它们之间的关系是？
	
执行环境 (execution context)：变量或函数有权访问的其他数据。也称“环境”。 <br>
全局执行环境：最外围的执行环境。在 Web 浏览器中，全局执行环境是 window 对象。<br> 
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。<br> 
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

每个执行环境都有一个与之关联的变量对象。

变量对象 (variable object)：保存环境中定义的所有变量和函数。代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br>
如果这个环境是**函数**，则将其**活动对象**作为变量对象。<br>
活动对象 (activation object)：最开始时只包含一个变量，即 arguments 对象 (这个对象在全局环境中是不存在的)。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。

作用域链 (scope chain)：保证对[执行环境有权访问的]所有变量和函数的有序访问。<br>
作用域链中，最前端始终都是当前执行的代码所在环境的变量对象。<br>
下一个变量对象来自包含 (外部) 环境，逐级向外，全局执行环境的变量对象始终是作用域链中的最后一个对象。<br>
作用域链本质上是一个**指向变量对象的指针列表**，它只引用但不实际包含变量对象。

---

Q：函数被创建和调用的过程中，执行环境、作用域链、活动对象分别是在何时生成的？

	function compare(value1, value2){
       if (value1 < value2){
          return -1;
       } else if (value1 > value2){
          return 1;
       } else {
          return 0; 
       }
	}
	
	var result = compare(5, 10);

以上代码定义了 compare() 函数，然后又在全局作用域中调用了它。<br>
在创建 compare() 函数时，会创建一个预先**包含全局变量对象的作用域链**，这个作用域链被保存在内部的[[Scope]]属性中。 <br>
当调用 compare() 函数时，会为函数创建一个**执行环境**，然后通过复制函数的[[Scope]]属性中的对象**构建起执行环境的作用域链**。<br>
此后，又有一个**活动对象 (在此作为变量对象使用)** 被创建并被推入执行环境作用域链的前端。<br>
使用 **arguments 和其他命名参数 (在此是 value1 和 value2) 的值**来初始化函数的活动对象。<br>
对于这个例子中 compare() 函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。<br>
全局执行环境的变量对象 (包含 result 和 compare) 在 compare() 执行环境的作用域链中处于第二位。

---

Q：对变量的访问规则？

在函数执行过程中访问一个变量时 (为读取和写入变量的值)，就会从作用域链中搜索具有相应名字的变量。<br>
标识符解析 (indentifier resolution)：沿着作用域链一级一级地搜索标识符的过程。<br>
搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。

---

Q：执行环境和变量对象的生命周期？

一般情况：
某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>
全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁。

全局环境的变量对象始终存在，而像 compare() 函数这样的局部环境的变量对象，则只在**函数执行**的过程中存在。<br>
一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域 (全局执行环境的变量对象)。<br>

但是，闭包的情况有所不同。

闭包 (closure)：有权访问另一个函数作用域中的变量的函数。<br>
创建闭包的常见方式，是在一个函数A内部创建另一个函数B (return function() {})。<br>
B会将外部函数A的活动对象添加到它的作用域链中，因此可以访问在A中定义的所有变量。<br>
当A函数返回后，**其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，因为B函数的作用域链仍然在引用这个活动对象**；直到B函数被销毁后，A的活动对象才会被销毁。

---
---

### keyword：块级作用域

* 高程 4.2.2 没有块级作用域 prof-scope (不太相关)
* 高程 7.3 模仿块级作用域 --> IIFE
* 你不知道的JS 3.3.2 IIFE

* 深入理解 ES6 第1章 块级作用域绑定 es6-block-scope --> let
* 你不知道的JS 3.4 块作用域 know-3-scope --> let
* 你不知道的JS 第4章 提升

* 你不知道的JS 5.3 IIFE和闭包

* 高程 4.3 垃圾收集

* 你不知道的JS 5.4 循环和闭包 know-closure

### keywords：递归，argument

* 高程 5.5.4 函数内部属性
* 高程 7.1 递归